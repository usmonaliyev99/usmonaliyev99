{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This page about me.","title":"Home"},{"location":"#home","text":"This page about me.","title":"Home"},{"location":"contact/","text":"My contacts Telegram Gmail Instagram Facebook X LinkedIn","title":"Contacts"},{"location":"contact/#my-contacts","text":"Telegram Gmail Instagram Facebook X LinkedIn","title":"My contacts"},{"location":"my-trip/","text":"My trip This page will be implemented one day","title":"My trip"},{"location":"my-trip/#my-trip","text":"This page will be implemented one day","title":"My trip"},{"location":"package/","text":"My packages I work with few languages and framewors but Laravel is one of loved framework of mine, it is very confortable and easy to understand. That is why I created few packages for Laravel. redium A high-performance laravel auth package powered by redis, inspired by sanctum. composer require usmonaliyev/redium To learn more and how to use this package, please consult the official documentation . laravel-simple-rabbitmq This package provides simple usage of rabbitmq. composer require usmonaliyev/laravel-simple-rabbitmq If you want to know see how to use it, go to github repository","title":"Packages"},{"location":"package/#my-packages","text":"I work with few languages and framewors but Laravel is one of loved framework of mine, it is very confortable and easy to understand. That is why I created few packages for Laravel.","title":"My packages"},{"location":"package/#redium","text":"A high-performance laravel auth package powered by redis, inspired by sanctum. composer require usmonaliyev/redium To learn more and how to use this package, please consult the official documentation .","title":"redium"},{"location":"package/#laravel-simple-rabbitmq","text":"This package provides simple usage of rabbitmq. composer require usmonaliyev/laravel-simple-rabbitmq If you want to know see how to use it, go to github repository","title":"laravel-simple-rabbitmq"},{"location":"skill/","text":"My skills This page will be implemented one day","title":"Skills"},{"location":"skill/#my-skills","text":"This page will be implemented one day","title":"My skills"},{"location":"docker/build/","text":"","title":"Build"},{"location":"docker/docker-compose/","text":"","title":"Docker compose"},{"location":"docker/install/","text":"Install Docker Engine on Ubuntu If you are in development, you can install it with single command: curl https://get.docker.com | sh Remove old Docker versions sudo apt-get remove -y docker docker-engine docker.io containerd runc Install using the apt repository Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker apt repository. Afterward, you can install and update Docker from the repository. Set up Docker's apt repository. # Add Docker's official GPG key: sudo apt update sudo apt install ca-certificates curl sudo install -m 0755 -d /etc/apt/keyrings sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc # Add the repository to Apt sources: sudo tee /etc/apt/sources.list.d/docker.sources <<EOF Types: deb URIs: https://download.docker.com/linux/ubuntu Suites: $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") Components: stable Signed-By: /etc/apt/keyrings/docker.asc EOF sudo apt update Install the Docker packages. sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin The Docker service starts automatically after installation. To verify that Docker is running, use: sudo systemctl status docker Verify that the installation is successful by running the hello-world image: sudo docker run hello-world This command downloads a test image and runs it in a container. When the container runs, it prints a confirmation message and exits. Source","title":"Install"},{"location":"docker/install/#install-docker-engine-on-ubuntu","text":"If you are in development, you can install it with single command: curl https://get.docker.com | sh Remove old Docker versions sudo apt-get remove -y docker docker-engine docker.io containerd runc Install using the apt repository Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker apt repository. Afterward, you can install and update Docker from the repository. Set up Docker's apt repository. # Add Docker's official GPG key: sudo apt update sudo apt install ca-certificates curl sudo install -m 0755 -d /etc/apt/keyrings sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc # Add the repository to Apt sources: sudo tee /etc/apt/sources.list.d/docker.sources <<EOF Types: deb URIs: https://download.docker.com/linux/ubuntu Suites: $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") Components: stable Signed-By: /etc/apt/keyrings/docker.asc EOF sudo apt update Install the Docker packages. sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin The Docker service starts automatically after installation. To verify that Docker is running, use: sudo systemctl status docker Verify that the installation is successful by running the hello-world image: sudo docker run hello-world This command downloads a test image and runs it in a container. When the container runs, it prints a confirmation message and exits. Source","title":"Install Docker Engine on Ubuntu"},{"location":"docker/unit/","text":"Running a Docker container via systemd Create systemd unit file sudo vim /etc/systemd/system/f-backend.service Example systemd unit for Docker container [Unit] Description=Friend backend docker container After=docker.service Requires=docker.service [Service] Restart=always TimeoutStartSec=0 ExecStartPre=-/usr/bin/docker rm -f f-backend ExecStart=/usr/bin/docker run \\ --name f-backend \\ --restart=no \\ -p 5000:5000 \\ -e PG_HOST=10.0.0.2 \\ -e PG_PORT=5432 \\ -e PG_PASSWORD=friend \\ -e PG_USER=supperpassword \\ gitlab.usmonaliyev99.com:5050/apps/f-backend:prod ExecStop=/usr/bin/docker stop f-backend [Install] WantedBy=multi-user.target I you use your container registry, please login before start systemd. docker login -u <user> -p <token|password> $CI_REGISTRY Reload & start service sudo systemctl daemon-reload sudo systemctl enable f-backend.service sudo systemctl start f-backend.service Check status & logs systemctl status f-backend.service journalctl -u f-backend.service -f If you want to expose it to world, use this nginx conf: server { listen 80; server_name f-backend.usmonaliyev99.com; access_log /var/log/nginx/f-backend.access.log; error_log /var/log/nginx/f-backend.error.log; location / { proxy_pass http://127.0.0.1:5000; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } }","title":"Running a Docker container via systemd"},{"location":"docker/unit/#running-a-docker-container-via-systemd","text":"Create systemd unit file sudo vim /etc/systemd/system/f-backend.service Example systemd unit for Docker container [Unit] Description=Friend backend docker container After=docker.service Requires=docker.service [Service] Restart=always TimeoutStartSec=0 ExecStartPre=-/usr/bin/docker rm -f f-backend ExecStart=/usr/bin/docker run \\ --name f-backend \\ --restart=no \\ -p 5000:5000 \\ -e PG_HOST=10.0.0.2 \\ -e PG_PORT=5432 \\ -e PG_PASSWORD=friend \\ -e PG_USER=supperpassword \\ gitlab.usmonaliyev99.com:5050/apps/f-backend:prod ExecStop=/usr/bin/docker stop f-backend [Install] WantedBy=multi-user.target I you use your container registry, please login before start systemd. docker login -u <user> -p <token|password> $CI_REGISTRY Reload & start service sudo systemctl daemon-reload sudo systemctl enable f-backend.service sudo systemctl start f-backend.service Check status & logs systemctl status f-backend.service journalctl -u f-backend.service -f If you want to expose it to world, use this nginx conf: server { listen 80; server_name f-backend.usmonaliyev99.com; access_log /var/log/nginx/f-backend.access.log; error_log /var/log/nginx/f-backend.error.log; location / { proxy_pass http://127.0.0.1:5000; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } }","title":"Running a Docker container via systemd"},{"location":"gitlab/base-image/","text":"Base image To build helm package and use kubectl in ci pipeline, we have to install kubectl, helm, etc tools before start pipeline. That is not good idea, that is why we created base image for it. Open repository in gitlab like k8s or helm : Create Dockerfile in it. FROM alpine:3.19 ARG KUBECTL_VERSION=v1.29.1 ARG HELM_VERSION=v3.14.1 # Base tools RUN apk add --no-cache \\ curl \\ ca-certificates \\ tar \\ gzip # Install kubectl RUN curl -fsSL https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl \\ -o /usr/local/bin/kubectl \\ && chmod +x /usr/local/bin/kubectl # Install helm RUN curl -fsSL https://get.helm.sh/helm-${HELM_VERSION}-linux-amd64.tar.gz \\ | tar -xz \\ && mv linux-amd64/helm /usr/local/bin/helm \\ && chmod +x /usr/local/bin/helm \\ && rm -rf linux-amd64 To build and push image, create .gitlab-ci.yml file: stages: - build .build: stage: build before_script: - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY script: - docker build -t $CI_REGISTRY_IMAGE:$TAG . - docker push $CI_REGISTRY_IMAGE:$TAG - docker rmi $CI_REGISTRY_IMAGE:$TAG build:latest: extends: .build variables: TAG: latest only: - main","title":"Base image"},{"location":"gitlab/base-image/#base-image","text":"To build helm package and use kubectl in ci pipeline, we have to install kubectl, helm, etc tools before start pipeline. That is not good idea, that is why we created base image for it. Open repository in gitlab like k8s or helm : Create Dockerfile in it. FROM alpine:3.19 ARG KUBECTL_VERSION=v1.29.1 ARG HELM_VERSION=v3.14.1 # Base tools RUN apk add --no-cache \\ curl \\ ca-certificates \\ tar \\ gzip # Install kubectl RUN curl -fsSL https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl \\ -o /usr/local/bin/kubectl \\ && chmod +x /usr/local/bin/kubectl # Install helm RUN curl -fsSL https://get.helm.sh/helm-${HELM_VERSION}-linux-amd64.tar.gz \\ | tar -xz \\ && mv linux-amd64/helm /usr/local/bin/helm \\ && chmod +x /usr/local/bin/helm \\ && rm -rf linux-amd64 To build and push image, create .gitlab-ci.yml file: stages: - build .build: stage: build before_script: - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY script: - docker build -t $CI_REGISTRY_IMAGE:$TAG . - docker push $CI_REGISTRY_IMAGE:$TAG - docker rmi $CI_REGISTRY_IMAGE:$TAG build:latest: extends: .build variables: TAG: latest only: - main","title":"Base image"},{"location":"gitlab/ci-cd-docker-unit/","text":"CI/CD for systemd docker First create systemd service. If you run your docker image with systemd, use this .gitlab-ci.yml : stages: - build - deploy variables: TAG: prod build: stage: build script: - docker build -t $CI_REGISTRY_IMAGE:$TAG . - docker push $CI_REGISTRY_IMAGE:$TAG - docker rmi $CI_REGISTRY_IMAGE:$TAG || true only: - main deploy: stage: deploy image: alpine:3.20 before_script: - apk add --no-cache openssh - mkdir -p ~/.ssh - echo \"$SSH_PRIVATE_KEY\" | tr -d '\\r' > ~/.ssh/id_rsa - chmod 600 ~/.ssh/id_rsa - ssh-keyscan $SSH_HOST >> ~/.ssh/known_hosts script: - ssh $SSH_USER@$SSH_HOST \"docker pull $CI_REGISTRY_IMAGE:$TAG\" - ssh $SSH_USER@$SSH_HOST \"systemctl restart $SERVICE_NAME\" only: - main","title":"CI/CD for systemd"},{"location":"gitlab/ci-cd-docker-unit/#cicd-for-systemd-docker","text":"First create systemd service. If you run your docker image with systemd, use this .gitlab-ci.yml : stages: - build - deploy variables: TAG: prod build: stage: build script: - docker build -t $CI_REGISTRY_IMAGE:$TAG . - docker push $CI_REGISTRY_IMAGE:$TAG - docker rmi $CI_REGISTRY_IMAGE:$TAG || true only: - main deploy: stage: deploy image: alpine:3.20 before_script: - apk add --no-cache openssh - mkdir -p ~/.ssh - echo \"$SSH_PRIVATE_KEY\" | tr -d '\\r' > ~/.ssh/id_rsa - chmod 600 ~/.ssh/id_rsa - ssh-keyscan $SSH_HOST >> ~/.ssh/known_hosts script: - ssh $SSH_USER@$SSH_HOST \"docker pull $CI_REGISTRY_IMAGE:$TAG\" - ssh $SSH_USER@$SSH_HOST \"systemctl restart $SERVICE_NAME\" only: - main","title":"CI/CD for systemd docker"},{"location":"gitlab/ci-cd/","text":"Gitlab CI/CD Let's start with simple CI/CD","title":"CI/CD"},{"location":"gitlab/ci-cd/#gitlab-cicd","text":"Let's start with simple CI/CD","title":"Gitlab CI/CD"},{"location":"gitlab/helm/","text":"Creating Your Own Charts The Chart Development Guide explains how to develop your own charts. But you can get started quickly by using the helm create command: helm create f-backend-chart cd f-backend-chart Now there is a chart in ./f-backend-chart. You can edit it and create your own templates. Linting As you edit your chart, you can validate that it is well-formed by running: helm lint Package When it's time to package the chart up for distribution, you can run: helm package . -d output-folder Install There are two way to install that chart. With *.tgz file: helm install f-backend-app ./output-folder/f-backend-chart-0.1.0.tgz Without tgz file, in development: helm install f-backend-app . Upgrade If you change that chart, you can upgrade your helm chart with: helm upgrade f-backend . Uninstall helm uninstall f-backend Always delete resources with helm that created by helm Upload tgz file to gitlab server with API curl --fail \\ --request POST \\ --user \"$USER:$PASSWORD\" \\ --form \"chart=@./f-backend-chart-0.1.0.tgz\" \\ \"https://gitlab.example.com/api/v4/projects/$PROJECT_ID/packages/helm/api/stable/charts\"","title":"helm"},{"location":"gitlab/helm/#creating-your-own-charts","text":"The Chart Development Guide explains how to develop your own charts. But you can get started quickly by using the helm create command: helm create f-backend-chart cd f-backend-chart Now there is a chart in ./f-backend-chart. You can edit it and create your own templates.","title":"Creating Your Own Charts"},{"location":"gitlab/helm/#linting","text":"As you edit your chart, you can validate that it is well-formed by running: helm lint","title":"Linting"},{"location":"gitlab/helm/#package","text":"When it's time to package the chart up for distribution, you can run: helm package . -d output-folder","title":"Package"},{"location":"gitlab/helm/#install","text":"There are two way to install that chart. With *.tgz file: helm install f-backend-app ./output-folder/f-backend-chart-0.1.0.tgz Without tgz file, in development: helm install f-backend-app .","title":"Install"},{"location":"gitlab/helm/#upgrade","text":"If you change that chart, you can upgrade your helm chart with: helm upgrade f-backend .","title":"Upgrade"},{"location":"gitlab/helm/#uninstall","text":"helm uninstall f-backend Always delete resources with helm that created by helm","title":"Uninstall"},{"location":"gitlab/helm/#upload-tgz-file-to-gitlab-server-with-api","text":"curl --fail \\ --request POST \\ --user \"$USER:$PASSWORD\" \\ --form \"chart=@./f-backend-chart-0.1.0.tgz\" \\ \"https://gitlab.example.com/api/v4/projects/$PROJECT_ID/packages/helm/api/stable/charts\"","title":"Upload tgz file to gitlab server with API"},{"location":"gitlab/runner/","text":"To install GitLab Runner Add the official GitLab repository: 1 Download the repository configuration script: curl -L \"https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh\" -o script.deb.sh 2 Inspect the script before running it: less script.deb.sh 3 Run the script: sudo bash script.deb.sh Install the latest version of GitLab Runner, or skip to the next step to install a specific version: sudo apt install gitlab-runner Source 4 After install gitlab runner, you should create volume for your worker to use docker in your pipeline. sudo vim /etc/gitlab-runner/config.toml Mount /var/run/docker.sock:/var/run/docker.sock file like this: [[runners]] name = \"docker-runner\" url = \"https://about.gitlab.com/\" token = \"your-token\" executor = \"docker\" [runners.custom_build_dir] [runners.docker] tls_verify = false image = \"docker:latest\" privileged = true disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [\"/cache\", \"/var/run/docker.sock:/var/run/docker.sock\"] shm_size = 0 5 After change config.toml , restart your gitlab runner sudo gitlab-runner restart","title":"Install gitLab runner"},{"location":"gitlab/runner/#to-install-gitlab-runner","text":"","title":"To install GitLab Runner"},{"location":"gitlab/runner/#add-the-official-gitlab-repository","text":"1 Download the repository configuration script: curl -L \"https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh\" -o script.deb.sh 2 Inspect the script before running it: less script.deb.sh 3 Run the script: sudo bash script.deb.sh","title":"Add the official GitLab repository:"},{"location":"gitlab/runner/#install-the-latest-version-of-gitlab-runner-or-skip-to-the-next-step-to-install-a-specific-version","text":"sudo apt install gitlab-runner Source 4 After install gitlab runner, you should create volume for your worker to use docker in your pipeline. sudo vim /etc/gitlab-runner/config.toml Mount /var/run/docker.sock:/var/run/docker.sock file like this: [[runners]] name = \"docker-runner\" url = \"https://about.gitlab.com/\" token = \"your-token\" executor = \"docker\" [runners.custom_build_dir] [runners.docker] tls_verify = false image = \"docker:latest\" privileged = true disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [\"/cache\", \"/var/run/docker.sock:/var/run/docker.sock\"] shm_size = 0 5 After change config.toml , restart your gitlab runner sudo gitlab-runner restart","title":"Install the latest version of GitLab Runner, or skip to the next step to install a specific version:"},{"location":"gitlab/server/","text":"Enable SSH and open firewall ports To open the needed firewall ports (80, 443, 22) and be able to access GitLab: Enable and start the OpenSSH server daemon: sudo systemctl enable --now ssh With ufw installed, open the firewall ports: sudo ufw allow 22/tcp sudo ufw allow 80/tcp sudo ufw allow 443/tcp sudo ufw enable Add the GitLab package repository To install GitLab, first add the GitLab package repository. Install the needed packages: sudo apt update sudo apt install -y curl Use the following script to add the GitLab repository (you can paste the script\u2019s URL to your browser to see what it does before piping it to bash): curl \"https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh\" | sudo bash Install the package Install GitLab using your system\u2019s package manager. sudo EXTERNAL_URL=\"https://gitlab.example.com\" apt install gitlab-ce GitLab generates a random password and email address for the root administrator account stored in /etc/gitlab/initial_root_password for 24 hours. After 24 hours, this file is automatically removed for security reasons. Source","title":"Setup gitlab server"},{"location":"gitlab/server/#enable-ssh-and-open-firewall-ports","text":"To open the needed firewall ports (80, 443, 22) and be able to access GitLab: Enable and start the OpenSSH server daemon: sudo systemctl enable --now ssh With ufw installed, open the firewall ports: sudo ufw allow 22/tcp sudo ufw allow 80/tcp sudo ufw allow 443/tcp sudo ufw enable","title":"Enable SSH and open firewall ports"},{"location":"gitlab/server/#add-the-gitlab-package-repository","text":"To install GitLab, first add the GitLab package repository. Install the needed packages: sudo apt update sudo apt install -y curl Use the following script to add the GitLab repository (you can paste the script\u2019s URL to your browser to see what it does before piping it to bash): curl \"https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh\" | sudo bash","title":"Add the GitLab package repository"},{"location":"gitlab/server/#install-the-package","text":"Install GitLab using your system\u2019s package manager. sudo EXTERNAL_URL=\"https://gitlab.example.com\" apt install gitlab-ce GitLab generates a random password and email address for the root administrator account stored in /etc/gitlab/initial_root_password for 24 hours. After 24 hours, this file is automatically removed for security reasons. Source","title":"Install the package"},{"location":"kubernetes/helm/","text":"Installing Helm From the Binary Releases Every release of Helm provides binary releases for a variety of OSes. These binary versions can be manually downloaded and installed. Download your desired version Unpack it (tar -zxvf helm-v4.0.0-linux-amd64.tar.gz) Find the helm binary in the unpacked directory, and move it to its desired destination (mv linux-amd64/helm /usr/local/bin/helm) From Script Helm now has an installer script that will automatically grab the latest version of Helm and install it locally. You can fetch that script, and then execute it locally. It's well documented so that you can read through it and understand what it is doing before you run it. curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-4 chmod 700 get_helm.sh ./get_helm.sh Yes, you can curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-4 | bash if you want to live on the edge. Commands Render templates (no install) helm template . It shows pure Kubernetes YAML helm template . \\ --set ingress.host=example.com \\ --set image.tag=123 You can overwrite default values. Lint chart (static checks) Finds syntax and logic errors helm lint . Install chart (first time) helm install friend-backend . friend-backend \u2192 release name . \u2192 chart path helm install friend-backend . \\ --set image.tag=3 \\ --set ingress.host=api.dev.local With changes values. Upgrade chart (most used) Helm: compares current release applies only diffs helm upgrade friend-backend . Upgrade + install (CI-safe): helm upgrade friend-backend . \\ --install \\ --set ingress.host=api.staging.local \\ --set image.tag=$CI_PIPELINE_IID See installed releases helm list Namespace-specific: helm list -n default Inspect release values helm get values friend-backend Source","title":"helm"},{"location":"kubernetes/helm/#installing-helm","text":"","title":"Installing Helm"},{"location":"kubernetes/helm/#from-the-binary-releases","text":"Every release of Helm provides binary releases for a variety of OSes. These binary versions can be manually downloaded and installed. Download your desired version Unpack it (tar -zxvf helm-v4.0.0-linux-amd64.tar.gz) Find the helm binary in the unpacked directory, and move it to its desired destination (mv linux-amd64/helm /usr/local/bin/helm)","title":"From the Binary Releases"},{"location":"kubernetes/helm/#from-script","text":"Helm now has an installer script that will automatically grab the latest version of Helm and install it locally. You can fetch that script, and then execute it locally. It's well documented so that you can read through it and understand what it is doing before you run it. curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-4 chmod 700 get_helm.sh ./get_helm.sh Yes, you can curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-4 | bash if you want to live on the edge.","title":"From Script"},{"location":"kubernetes/helm/#commands","text":"Render templates (no install) helm template . It shows pure Kubernetes YAML helm template . \\ --set ingress.host=example.com \\ --set image.tag=123 You can overwrite default values. Lint chart (static checks) Finds syntax and logic errors helm lint . Install chart (first time) helm install friend-backend . friend-backend \u2192 release name . \u2192 chart path helm install friend-backend . \\ --set image.tag=3 \\ --set ingress.host=api.dev.local With changes values. Upgrade chart (most used) Helm: compares current release applies only diffs helm upgrade friend-backend . Upgrade + install (CI-safe): helm upgrade friend-backend . \\ --install \\ --set ingress.host=api.staging.local \\ --set image.tag=$CI_PIPELINE_IID See installed releases helm list Namespace-specific: helm list -n default Inspect release values helm get values friend-backend Source","title":"Commands"},{"location":"kubernetes/k3s/","text":"Install Script K3s provides an installation script that is a convenient way to install it as a service on systemd or openrc based systems. This script is available at https://get.k3s.io. To install K3s using this method, just run: curl -sfL https://get.k3s.io | sh - After running this installation: The K3s service will be configured to automatically restart after node reboots or if the process crashes or is killed Additional utilities will be installed, including kubectl, crictl, ctr, k3s-killall.sh, and k3s-uninstall.sh A kubeconfig file will be written to /etc/rancher/k3s/k3s.yaml and the kubectl installed by K3s will automatically use it Source","title":"k3s"},{"location":"kubernetes/k3s/#install-script","text":"K3s provides an installation script that is a convenient way to install it as a service on systemd or openrc based systems. This script is available at https://get.k3s.io. To install K3s using this method, just run: curl -sfL https://get.k3s.io | sh - After running this installation: The K3s service will be configured to automatically restart after node reboots or if the process crashes or is killed Additional utilities will be installed, including kubectl, crictl, ctr, k3s-killall.sh, and k3s-uninstall.sh A kubeconfig file will be written to /etc/rancher/k3s/k3s.yaml and the kubectl installed by K3s will automatically use it Source","title":"Install Script"},{"location":"kubernetes/minikube/","text":"Install minikube minikube is local Kubernetes, focusing on making it easy to learn and develop for Kubernetes. All you need is Docker (or similarly compatible) container or a Virtual Machine environment, and Kubernetes is a single command away: minikube start What you\u2019ll need 2 CPUs or more 2GB of free memory 20GB of free disk space Internet connection Container or virtual machine manager, such as: Docker, QEMU, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox, or VMware Fusion/Workstation Installation To install the latest minikube stable release on x86-64 Linux using binary download: curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube && rm minikube-linux-amd64 Start your cluster From a terminal with administrator access (but not logged in as root), run: minikube start Enable ingress addon: minikube addons enable ingress Manage your cluster Pause Kubernetes without impacting deployed applications: minikube pause Unpause a paused instance: minikube unpause Halt the cluster: minikube stop Change the default memory limit (requires a restart): minikube config set memory 9001 Browse the catalog of easily installed Kubernetes services: minikube addons list Create a second cluster running an older Kubernetes release: minikube start -p aged --kubernetes-version=v1.34.0 Delete all of the minikube clusters: minikube delete --all Source","title":"Minikube"},{"location":"kubernetes/minikube/#install-minikube","text":"minikube is local Kubernetes, focusing on making it easy to learn and develop for Kubernetes. All you need is Docker (or similarly compatible) container or a Virtual Machine environment, and Kubernetes is a single command away: minikube start What you\u2019ll need 2 CPUs or more 2GB of free memory 20GB of free disk space Internet connection Container or virtual machine manager, such as: Docker, QEMU, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox, or VMware Fusion/Workstation Installation To install the latest minikube stable release on x86-64 Linux using binary download: curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube && rm minikube-linux-amd64 Start your cluster From a terminal with administrator access (but not logged in as root), run: minikube start Enable ingress addon: minikube addons enable ingress Manage your cluster Pause Kubernetes without impacting deployed applications: minikube pause Unpause a paused instance: minikube unpause Halt the cluster: minikube stop Change the default memory limit (requires a restart): minikube config set memory 9001 Browse the catalog of easily installed Kubernetes services: minikube addons list Create a second cluster running an older Kubernetes release: minikube start -p aged --kubernetes-version=v1.34.0 Delete all of the minikube clusters: minikube delete --all Source","title":"Install minikube"},{"location":"kubernetes/rbac/","text":"RBAC Create service account Create namespace for account: kubectl create namespace prod Create service account in that namespace: kubectl create serviceaccount gitlab-prod-deployer -n prod Create role Let's create deployer role: kubectl create role deployer --verb get,list,watch,create,update,patch,delete --resource pods,deployments,services,ingress,configmaps,secrets,replicasets,endpoints -n prod Create role binding Template: kubectl create rolebinding <name> --serviceaccount <namespace>:<serviceaccount> --role <role-name> -n <namespace> Example: kubectl create rolebinding gitlab-prod-deployer --serviceaccount prod:gitlab-prod-deployer --role deployer -n prod Check: kubectl auth can-i list pods -n prod --as=system:serviceaccount:prod:gitlab-prod-deployer Yes => OK No => Something went wrong Create token Template: kubectl create token <serviceaccount> -n <namespace> --duration *h # 1 year == 8760 hour kubectl create token gitlab-prod-deployer -n prod --duration=8760h Generate deployer config apiVersion: v1 kind: Config clusters: - cluster: server: https://<YOUR_SERVER_PUBLIC_IP>:6443 certificate-authority-data: <BASE64_CA_CERT> name: <CLUSTER_NAME> contexts: - context: cluster: <CLUSTER_NAME> namespace: <NAMESPACE> user: <SERVICE_ACCOUNT_NAME> name: <CONTEXT_NAME> current-context: <CONTEXT_NAME> users: - name: <SERVICE_ACCOUNT_NAME> user: token: <TOKEN_NEWLY_CREATED> WHERE the cluster is (clusters) WHAT you\u2019re allowed to do & where (contexts) WHO you are (users) \ud83d\udd11 certificate-authority-data certificate-authority-data: <BASE64_CA_CERT> This is: The CA certificate that signed your API server TLS cert Used to verify the server is trusted Prevents MITM attacks Where to get it your admin cluster config (k3s.yaml or admin.conf)","title":"RBAC"},{"location":"kubernetes/rbac/#rbac","text":"","title":"RBAC"},{"location":"kubernetes/rbac/#create-service-account","text":"Create namespace for account: kubectl create namespace prod Create service account in that namespace: kubectl create serviceaccount gitlab-prod-deployer -n prod","title":"Create service account"},{"location":"kubernetes/rbac/#create-role","text":"Let's create deployer role: kubectl create role deployer --verb get,list,watch,create,update,patch,delete --resource pods,deployments,services,ingress,configmaps,secrets,replicasets,endpoints -n prod","title":"Create role"},{"location":"kubernetes/rbac/#create-role-binding","text":"Template: kubectl create rolebinding <name> --serviceaccount <namespace>:<serviceaccount> --role <role-name> -n <namespace> Example: kubectl create rolebinding gitlab-prod-deployer --serviceaccount prod:gitlab-prod-deployer --role deployer -n prod Check: kubectl auth can-i list pods -n prod --as=system:serviceaccount:prod:gitlab-prod-deployer Yes => OK No => Something went wrong","title":"Create role binding"},{"location":"kubernetes/rbac/#create-token","text":"Template: kubectl create token <serviceaccount> -n <namespace> --duration *h # 1 year == 8760 hour kubectl create token gitlab-prod-deployer -n prod --duration=8760h","title":"Create token"},{"location":"kubernetes/rbac/#generate-deployer-config","text":"apiVersion: v1 kind: Config clusters: - cluster: server: https://<YOUR_SERVER_PUBLIC_IP>:6443 certificate-authority-data: <BASE64_CA_CERT> name: <CLUSTER_NAME> contexts: - context: cluster: <CLUSTER_NAME> namespace: <NAMESPACE> user: <SERVICE_ACCOUNT_NAME> name: <CONTEXT_NAME> current-context: <CONTEXT_NAME> users: - name: <SERVICE_ACCOUNT_NAME> user: token: <TOKEN_NEWLY_CREATED> WHERE the cluster is (clusters) WHAT you\u2019re allowed to do & where (contexts) WHO you are (users) \ud83d\udd11 certificate-authority-data certificate-authority-data: <BASE64_CA_CERT> This is: The CA certificate that signed your API server TLS cert Used to verify the server is trusted Prevents MITM attacks Where to get it your admin cluster config (k3s.yaml or admin.conf)","title":"Generate deployer config"},{"location":"networking/console/","text":"Console In first time, we connect to router or switch with console cable. We have to secure this connection. When you entered router, you are in user exec mode, like: Router> Switch> You need to jump into privileged exec mode: enable It look like this: Router# Switch# Go to global configuration mode with: configure terminal After that command, you see like this: Router(config)# Switch(config)# Select console line with: line console 0 It gives: Router(config-line)# Switch(config-line)# Now we cat put password on that line: password 123 login It's done, you can exit with exit command You can encrypt that password in global configuration mode with: service password-encryption","title":"Console"},{"location":"networking/console/#console","text":"In first time, we connect to router or switch with console cable. We have to secure this connection. When you entered router, you are in user exec mode, like: Router> Switch> You need to jump into privileged exec mode: enable It look like this: Router# Switch# Go to global configuration mode with: configure terminal After that command, you see like this: Router(config)# Switch(config)# Select console line with: line console 0 It gives: Router(config-line)# Switch(config-line)# Now we cat put password on that line: password 123 login It's done, you can exit with exit command You can encrypt that password in global configuration mode with: service password-encryption","title":"Console"},{"location":"networking/devices/","text":"Network devices There are few devices to work with network: Router Switch Hub Modem Firewall Access point Server Client device Load balancer","title":"Devices"},{"location":"networking/devices/#network-devices","text":"There are few devices to work with network: Router Switch Hub Modem Firewall Access point Server Client device Load balancer","title":"Network devices"},{"location":"networking/modes/","text":"Main cisco CLI modes User EXEC Mode Router> Switch> Purpose: Basic monitoring only No configuration allowed Privileged EXEC Mode Router# Switch# Enter with: enable Purpose: Full monitoring access Can enter configuration modes Global configuration mode Prompt: Router(config)# Switch(config)# Enter with: configure terminal Purpose: Configure the entire device","title":"Modes"},{"location":"networking/modes/#main-cisco-cli-modes","text":"User EXEC Mode Router> Switch> Purpose: Basic monitoring only No configuration allowed Privileged EXEC Mode Router# Switch# Enter with: enable Purpose: Full monitoring access Can enter configuration modes Global configuration mode Prompt: Router(config)# Switch(config)# Enter with: configure terminal Purpose: Configure the entire device","title":"Main cisco CLI modes"},{"location":"networking/ssh/","text":"Login with ssh Let's setup remote ssh login our devices. You need: Hostname Domain name RSA keys Local user account VTY lines configured for SSH Set Hostname Jump into global configuration mode and write: Router(config)# hostname Router1 Switch(config)# hostname Switch1 Set domain name Router(config)# ip domain-name lab.uz Create local user Router(config)# username USER secret PASSWORD Create rsa key Router(config)# crypto key generate rsa How many bits? 1024 or 2048 Enable ssh version 2 Router(config)# ip ssh version 2 Configure vty line for ssh only Router(config)# line vty 0 15 Router(config-line)# login local Router(config-line)# transport input ssh Verify ssh is enabled Router# show ip ssh Test ssh -L USER IP_ADDRESS","title":"Login with ssh"},{"location":"networking/ssh/#login-with-ssh","text":"Let's setup remote ssh login our devices. You need: Hostname Domain name RSA keys Local user account VTY lines configured for SSH Set Hostname Jump into global configuration mode and write: Router(config)# hostname Router1 Switch(config)# hostname Switch1 Set domain name Router(config)# ip domain-name lab.uz Create local user Router(config)# username USER secret PASSWORD Create rsa key Router(config)# crypto key generate rsa How many bits? 1024 or 2048 Enable ssh version 2 Router(config)# ip ssh version 2 Configure vty line for ssh only Router(config)# line vty 0 15 Router(config-line)# login local Router(config-line)# transport input ssh Verify ssh is enabled Router# show ip ssh Test ssh -L USER IP_ADDRESS","title":"Login with ssh"},{"location":"networking/sub-modes/","text":"Sub-configuration modes (Inside global config) Interface configuration mode Prompt: Router(config-if)# Enter with: interface gigabitEthernet0/0 Used for: IP address config Enable/disable interface Speed/duplex VLAN access/trunk settings Line configuration mode Prompt: Router(config-line)# Enter with: line console 0 line vty 0 4 Used for: Console, SSH, Telnet security Router configuration mode (Routing protocols) Prompt: Router(config-router)# Enter with: router rip router ospf 1 router bgp 65000 VLAN configuration mode (Switch) Prompt: Switch(config-vlan)# Enter with: vlan 10 Access control list mode Prompt: Router(config-std-nacl)# Router(config-ext-nacl)# Policy / Class map mode (QoS) Prompt: Router(config-pmap)# ROM monitor mode (Recovery mode) Prompt: rommon> Used for: Password recovery Boot troubleshooting","title":"SubModes"},{"location":"networking/sub-modes/#sub-configuration-modes-inside-global-config","text":"Interface configuration mode Prompt: Router(config-if)# Enter with: interface gigabitEthernet0/0 Used for: IP address config Enable/disable interface Speed/duplex VLAN access/trunk settings Line configuration mode Prompt: Router(config-line)# Enter with: line console 0 line vty 0 4 Used for: Console, SSH, Telnet security Router configuration mode (Routing protocols) Prompt: Router(config-router)# Enter with: router rip router ospf 1 router bgp 65000 VLAN configuration mode (Switch) Prompt: Switch(config-vlan)# Enter with: vlan 10 Access control list mode Prompt: Router(config-std-nacl)# Router(config-ext-nacl)# Policy / Class map mode (QoS) Prompt: Router(config-pmap)# ROM monitor mode (Recovery mode) Prompt: rommon> Used for: Password recovery Boot troubleshooting","title":"Sub-configuration modes (Inside global config)"}]}